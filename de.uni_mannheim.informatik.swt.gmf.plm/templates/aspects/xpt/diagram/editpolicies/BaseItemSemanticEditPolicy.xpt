/*******************************************************************************
 * Copyright (c) 2011 University of Mannheim: Chair for Software Engineering
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Ralph Gerbig - initial API and implementation and initial documentation
 *******************************************************************************/

«IMPORT 'http://www.eclipse.org/gmf/2009/GenModel'»
«IMPORT 'http://www.eclipse.org/emf/2002/GenModel'»

«EXTENSION xpt::diagram::editpolicies::Utils»
«EXTENSION xpt::diagram::Utils»
«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::OclMigrationProblems»

/*
  *
  * Alow domain connections to have more than one participant. Workaround for BUG xxx
  * Use the reasoning engine to determine if a DSL connection can be created.
  *
  */
«AROUND canCreate FOR gmfgen::GenLink»
	«IF getUniqueIdentifier().startsWith('ConnectionParticipant_')»
			
		«EXPAND xpt::Common::generatedMemberComment»
		public boolean canCreate«getUniqueIdentifier()»(«EXPAND canCreateParameters FOR modelFacet») {
			
			//left out contains check to have multiple participants to the same clabject. Workaround for BUG XXXX
			
			de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor editor = (de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor) org.eclipse.ui.PlatformUI
					.getWorkbench().getActiveWorkbenchWindow().getActivePage()
					.getActiveEditor();

			if (editor.getPalette().getActiveTool().getId().startsWith("dsl.")) {

				de.uni_mannheim.informatik.swt.plm.workbench.interfaces.IReasoningService reasoner = null;
				
				try {
					reasoner = de.uni_mannheim.informatik.swt.plm.workbench.ExtensionPointService.Instance().getActiveReasoningService().Instance();
				} catch (org.eclipse.core.runtime.CoreException e) {
					e.printStackTrace();
				}
				String typeID = editor.getPalette().getActiveTool().getId().replace("dsl.", "").replaceAll("<<.*?>>", "").replace(".CreationTool", "");
				de.uni_mannheim.informatik.swt.models.plm.PLM.Connection typeConnection = (de.uni_mannheim.informatik.swt.models.plm.PLM.Connection)reasoner.getElementByXMIID(typeID, source);
				//Start of drawing the line. possible if the source conforms what was used to construct the participation from
				if (source != null && target == null){
					return reasoner.neighbourhoodConstructionConformsConnection(typeConnection, source);
				}
				if (source.equals(target)) {
					return false;
				}
				java.util.Set<de.uni_mannheim.informatik.swt.models.plm.PLM.Connection> possibleTypeConnections = new java.util.HashSet<de.uni_mannheim.informatik.swt.models.plm.PLM.Connection>();
				possibleTypeConnections.add(typeConnection);
				for (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject con: typeConnection.getModelSupertypes())
					possibleTypeConnections.add((de.uni_mannheim.informatik.swt.models.plm.PLM.Connection) con);
				java.util.Set<de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject> possibleTypes = new java.util.HashSet<de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject>();
				for (de.uni_mannheim.informatik.swt.models.plm.PLM.Connection con: possibleTypeConnections)
					possibleTypes.addAll(con.getParticipant());
				for (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject possible: possibleTypes)
					if (reasoner.run(de.uni_mannheim.informatik.swt.plm.workbench.interfaces.IReasoningService.LOCAL_CONFORMS, new Object[]{possible, target}, true))
						return true;
				return false;
			}
			
			return canExist«getUniqueIdentifier()»(«EXPAND canCreateValues FOR modelFacet»);
		}
	«ELSEIF getUniqueIdentifier().startsWith('Role_')»
		«EXPAND xpt::Common::generatedMemberComment»
		public boolean canCreate«getUniqueIdentifier()»(«EXPAND canCreateParameters FOR modelFacet») {
		
			//Can cause BUG XXX (Cannot add two particpants to one connection due to unique lists)
			«EXPAND checkEMFConstraints FOR modelFacet-»
		
			//*************************************************************
			// BEGIN CUSTOM CODE
			//*************************************************************
			de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor editor = (de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor) org.eclipse.ui.PlatformUI
					.getWorkbench().getActiveWorkbenchWindow().getActivePage()
					.getActiveEditor();
	
			//In DSL mode?
			if (editor.getPalette().getActiveTool().getId().startsWith("dsl."))
			{
				String typeRoleID = editor.getPalette().getActiveTool().getId()
						.replace("dsl.", "").replaceAll("<<.*?>>", "")
						.replace(".CreationTool", "");
				de.uni_mannheim.informatik.swt.models.plm.PLM.Role typeRole = null;
				
				org.eclipse.emf.common.util.TreeIterator<org.eclipse.emf.ecore.EObject> iter = org.eclipse.emf.ecore.util.EcoreUtil.getRootContainer(source)
						.eAllContents();
				while (iter.hasNext()) 
				{
					org.eclipse.emf.ecore.EObject current = iter.next();
					if (org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getProxyID(current).equals(typeRoleID))
						typeRole = (de.uni_mannheim.informatik.swt.models.plm.PLM.Role) current;
				}
					
				//Check for the source -> Connection can be started
				if (source != null && target == null) 
				{
					if (typeRole != null){
						de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject sourceType = typeRole.getSource();
						java.util.LinkedList<de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject> possibleSourceTypes = new java.util.LinkedList<de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject>();
						possibleSourceTypes.addAll(sourceType.getModelSubtypes());
						possibleSourceTypes.addAll(sourceType.getModelSupertypes());
						possibleSourceTypes.add(sourceType);
							
						for (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject c : source.getModelTypes())
							if(possibleSourceTypes.contains(c))
								return true;
							
						return false;
					}
				}
					
				//Check for the target ->Connection can be finished
				if (target != null && editor.getPalette().getActiveTool().getId().startsWith("dsl.")) 
				{
					if (typeRole != null)
					{
						de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject targetType = typeRole.getDestination();
						java.util.LinkedList<de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject> possibleTargetTypes = new java.util.LinkedList<de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject>();
						possibleTargetTypes.addAll(targetType.getModelSubtypes());
						possibleTargetTypes.addAll(targetType.getModelSupertypes());
						possibleTargetTypes.add(targetType);
						
						for (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject c : target.getModelTypes())
							if(possibleTargetTypes.contains(c))
								return true;
							
						return false;
					}
				}
			}
			//*************************************************************
			// BEGIN CUSTOM CODE
			//*************************************************************
			
			return canExist«getUniqueIdentifier()»(«EXPAND canCreateValues FOR modelFacet»);
		}
	«ELSE»
		«targetDef.proceed()»
	«ENDIF»
«ENDAROUND»

«DEFINE checkEMFConstraints FOR gmfgen::TypeLinkModelFacet-»
	«LET childMetaFeature <> containmentMetaFeature and not isUnbounded(childMetaFeature.ecoreFeature) AS checkChildFeatureBounds-»
		«IF not isUnbounded(containmentMetaFeature.ecoreFeature) or checkChildFeatureBounds-»
if («getContainerVariable(self)» != null) {
			«EXPAND checkEMFConstraints(self) FOR containmentMetaFeature-»
			«IF checkChildFeatureBounds-»
				«EXPAND checkEMFConstraints(self) FOR childMetaFeature-»
			«ENDIF-»
}
		«ENDIF-»
	«ENDLET-»
«ENDDEFINE»

// FIXME mark as private (_) and move to impl::<find proper place>::LinkConstraints.xpt
«DEFINE canCreateParameters FOR gmfgen::LinkModelFacet»«EXPAND sourceTargetParameters»«ENDDEFINE»// source and target are reasonable defaults
«DEFINE canCreateParameters FOR gmfgen::TypeLinkModelFacet»«IF hasContainerOtherThanSource(self)»«EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» container, «ENDIF»«EXPAND sourceTargetParameters»«ENDDEFINE»

«DEFINE sourceTargetParameters FOR gmfgen::LinkModelFacet»«EXPAND MetaModel::QualifiedClassName FOR getSourceType()» source, «EXPAND MetaModel::QualifiedClassName FOR getTargetType()» target«ENDDEFINE»

// these are in fact 'canExist' values
«DEFINE canCreateValues FOR gmfgen::LinkModelFacet»source, target«ENDDEFINE» // defaults
«DEFINE canCreateValues FOR gmfgen::TypeLinkModelFacet»«IF hasContainerOtherThanSource(self)»container, «ENDIF»null, source, target«ENDDEFINE»