context Ontology {
	constraint notComputedOrIrrelevant {
		check: self.expressed and self.relevant
		message: 'Ontologies cannot be computed or irrelevant.'
		fix {
			title: 'Set expressed and relevant to true'
			do {
              self.expressed := true;
              self.relevant := true;
          }
		}
	}
}

context Clabject {

	constraint potencyNotNegative {
		check: self.potency > -2
		message: self.name + ' potency cannot be negative'
		fix {
			title: 'Set potency to *'
			do {self.potency := -1;}
		}
		fix {
			title: 'Compute potency based on types'
			do {
				--tbd
			}
		}
	}
	
	constraint levelNotNegative {
		check: self.level > -1
		message: self.name + ' level cannot be negative'
		fix {
			title: 'Set level to the level of the model'
			do {self.level := self.getModel().getLevel();}
		}
	}
	
	constraint levelNotModel {
		guard: self.level > -1
		check: self.level = self.getModel().getLevel()
		message: self.name + ' level does not match Model level'
		fix {
			title: 'Set level to the level of the model'
			do {self.level := self.getModel().getLevel();}
		}
	}
	
	constraint visualizerDurability {
		guard: self.potency > -2
		check: (self.potency = -1) or (self.visualizer->forAll(v|v.durability <= self.potency))
		message: self.name + ' has a visualizer of incorrect durability'
		fix {
			title: 'Set all mismatching visualizer.durability to ' + self.potency
			do {
				for (v in self.visualizer->select(v|v.durability > self.potency)) {
					v.durability := self.potency;
				}
			}
		}
	}
	
	constraint featureNameUnique {
		guard: self.feature->size() > 0
		check {
		 var names =  self.feature->collect(f|f.name);
		 return names->forAll(n|names.count(n) = 1);
		}
		message: self.name + ' defines features with duplicate names'
	}

}