/*******************************************************************************
 * Copyright (c) 2011 University of Mannheim: Chair for Software Engineering
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Ralph Gerbig - initial API and implementation and initial documentation
 *******************************************************************************/

«IMPORT 'http://www.eclipse.org/gmf/2009/GenModel'»

//**************************************************************
//ADDITIONS
//handle notifictaion is overriden later in this transformation
//**************************************************************
«AROUND additions FOR gmfgen::GenNode»
//Gives the option to diplay a Connection/Generalization/Specialization as black rectangle
«IF self.editPartClassName = 'ConnectionEditPart' 
	or self.editPartClassName = 'GeneralizationEditPart'»
	
	«EXPAND getToggleValue-»
	«EXPAND toggle-»
«ENDIF»
«IF self.editPartClassName = 'EntityEditPart'
		or self.editPartClassName = 'ConnectionEditPart'»
	«EXPAND doElide-»
«ENDIF»
«IF self.editPartClassName = 'EntityEditPart'
		or self.editPartClassName = 'ConnectionEditPart'
		or self.editPartClassName = 'GeneralizationEditPart'
		or self.editPartClassName = 'ComplementEditPart'
		or self.editPartClassName = 'EqualityEditPart'
		or self.editPartClassName = 'InversionEditPart'»

	«EXPAND setExpressedVisualState-»
	«EXPAND addNotify-»
	«EXPAND registerToHandleNotificationForChildren-»
«ENDIF»
«ENDAROUND»

//**************************************************************
//HANDLE NOTIFICATION
//**************************************************************
«AROUND handleNotificationEvent FOR gmfgen::GenNode-»
«IF self.editPartClassName = 'ConnectionEditPart'
	or self.editPartClassName = 'GeneralizationEditPart'
	or self.editPartClassName = 'EntityEditPart'
	or self.editPartClassName = 'ComplementEditPart'
	or self.editPartClassName = 'EqualityEditPart'
	or self.editPartClassName = 'InversionEditPart'»

	«EXPAND handleNotificationEventForClabjectLogicElement-»
«ELSEIF self.editPartClassName.startsWith('Attribute')»
	«EXPAND handleNotificationEventForAttribute-»
«ELSEIF self.editPartClassName.startsWith('Method')»
	«EXPAND handleNotificationEventForMethod-»
«ELSEIF self.editPartClassName = 'ModelEditPart'»
	«EXPAND handleNotificationEventForModel-»
«ELSEIF self.editPartClassName = 'OntologyEditPart'»
	«EXPAND handleNotificationEventForOntology»
«ENDIF»
«ENDAROUND»

«DEFINE handleNotificationEventForClabjectLogicElement FOR gmfgen::GenNode»
	/**
	 * Updates the connections after a value was set and does elision
	 *
	 * @generated
	 */
	@Override
	protected void handleNotificationEvent(org.eclipse.emf.common.notify.Notification notification) {
		super.handleNotificationEvent(notification);

		«IF self.editPartClassName = 'ConnectionEditPart'
				or self.editPartClassName = 'EntityEditPart'»
		//*************************************************************************
		//We want to update the DSL notation for Entities
		//*************************************************************************
		if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Attribute
				&& ((org.eclipse.emf.ecore.EStructuralFeature) notification.getFeature()).getName().equals("value"))
			updateView();
		«ENDIF»
		
		if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer) {
			updateView();
			
			«IF self.editPartClassName = 'ConnectionEditPart'
				or self.editPartClassName = 'EntityEditPart'»
			//*************************************************************************
			//Manage the classifications view state according to proximity indication
			//*************************************************************************
			org.eclipse.gmf.runtime.notation.View v = this.getNotationView();
			de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer LMLVisualizer = (de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer) notification
					.getNotifier();

			java.util.HashSet<org.eclipse.gmf.runtime.notation.View> outgoingEdges = new java.util.HashSet<org.eclipse.gmf.runtime.notation.View>();
			org.eclipse.ocl.ecore.OCL ocl = org.eclipse.ocl.ecore.OCL
					.newInstance();

			org.eclipse.ocl.helper.OCLHelper<org.eclipse.emf.ecore.EClassifier, ?, ?, org.eclipse.ocl.ecore.Constraint> helper = ocl
					.createOCLHelper();
			helper.setContext(org.eclipse.gmf.runtime.notation.NotationPackage.Literals.VIEW);

			try {
				//Need to take care to only select classification - plm::Classification is not known here..
				org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper
						.createQuery("Edge.allInstances()->select(e | e.source = self)->select(e | e.element.oclIsUndefined() <> true)");
				outgoingEdges = ((java.util.HashSet<org.eclipse.gmf.runtime.notation.View>) ocl.evaluate(v, q));
			} catch (org.eclipse.ocl.ParserException e) {
				e.printStackTrace();
			}
			
			java.util.LinkedList<org.eclipse.gmf.runtime.notation.View> outgoingClassificationEdges = new java.util.LinkedList<org.eclipse.gmf.runtime.notation.View>();
			
			//Only take views of Classifications
			for (org.eclipse.gmf.runtime.notation.View c : outgoingEdges)
				if (c.getElement() instanceof  de.uni_mannheim.informatik.swt.models.plm.PLM.Classification)
					outgoingClassificationEdges.add(c);
			
			//This has currently no support for multiple classifications
			if (outgoingClassificationEdges.size() > 0) {
				if ("1".equals(LMLVisualizer
						.getValueForKey("ProximityClassification")))
					outgoingClassificationEdges.get(0).setVisible(false);
				else
					outgoingClassificationEdges.get(0).setVisible(true);

				org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart edgeEP = (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart) getViewer()
						.getEditPartRegistry().get(outgoingClassificationEdges.get(0));

				if (edgeEP != null)
					edgeEP.performRequest(new org.eclipse.gef.Request(
							org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
			}
			«ENDIF»
		}
		
		org.eclipse.emf.ecore.EStructuralFeature changedFeature = (org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature();
		
		if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Element)
		{
			if (changedFeature.getName().equalsIgnoreCase("elided")|| 
				changedFeature.getName().equalsIgnoreCase("expressed"))
			{
				updateView();
			}
			«IF self.editPartClassName='EntityEditPart' or self.editPartClassName='ConnectionEditPart'»
			else if (changedFeature.getName().equals("potency"))
			{
				for(org.eclipse.emf.ecore.EObject eObj : ((de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject)resolveSemanticElement()).getFeature())
				{
					findEditPart(this, eObj).performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
				}
			}
			«ENDIF»
			«IF self.editPartClassName='EntityEditPart'»
			else if (changedFeature.getName().equals("name"))
			{
				de.uni_mannheim.informatik.swt.models.plm.PLM.Feature[] feature = new de.uni_mannheim.informatik.swt.models.plm.PLM.Feature[] {};
			
				org.eclipse.ocl.ecore.OCL ocl = org.eclipse.ocl.ecore.OCL.newInstance();
				org.eclipse.ocl.helper.OCLHelper<org.eclipse.emf.ecore.EClassifier, ?, ?, org.eclipse.ocl.ecore.Constraint> helper = ocl.createOCLHelper();
				helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.LML_MODEL);
				
				try {
					org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper
							.createQuery("Feature.allInstances()");
					feature = ((java.util.HashSet<de.uni_mannheim.informatik.swt.models.plm.PLM.Feature>) ocl
							.evaluate(org.eclipse.emf.ecore.util.EcoreUtil
									.getRootContainer(resolveSemanticElement()), q))
							.toArray(new de.uni_mannheim.informatik.swt.models.plm.PLM.Feature[] {});
				} catch (org.eclipse.ocl.ParserException e) {
					e.printStackTrace();
				}
			
				//We found feature
				if (feature.length > 0) {
					org.eclipse.ui.IEditorPart editor = org.eclipse.ui.PlatformUI.getWorkbench()
							.getActiveWorkbenchWindow().getActivePage()
							.getActiveEditor();
					if (!(editor instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor))
						return;

					de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor plmEditor = (de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor) editor;

					for (de.uni_mannheim.informatik.swt.models.plm.PLM.Feature f : feature) 
					{	
						//if a attribute is hidden via the notational model it cannot be resolved
						java.util.List featureEditParts = 
							 plmEditor.getDiagramGraphicalViewer().findEditPartsForElement(org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getProxyID(f),org.eclipse.gef.NodeEditPart.class);
					
					 	if (featureEditParts.size() > 0)
					 	{
							 org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart featureEditPart = (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart)featureEditParts.get(0);
							 featureEditPart.performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
						}
					}
				}
			}
			«ENDIF»
			
			«IF self.editPartClassName = 'EntityEditPart' or self.editPartClassName = 'ConnectionEditPart'»
			if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer && 
				((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("LMLVisualizersShown"))
			{
				«EXPAND showHideLMLVisualizers FOR self»
			}
			else if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer && 
				((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("origin")) 
			{
				«EXPAND ShowHideExpressed FOR self»
			}
			«ENDIF»
		}
	}
	
	/**
	 * 
	 * @return null if no DSLRendering infotmation is available, else true or false
	 *
	 * @generated
	 */
	private Boolean getDSLRenderingValue() {
		//boolean collapse = false;

		//********************************************************
		//Find the LMLVisualizer attached to this element 
		//********************************************************
		de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element) this
				.resolveSemanticElement();

		//No rendering information found => all Connection remains expanded
		if (self.getVisualizer().size() == 0) {
			//Hide external name label
			org.eclipse.draw2d.IFigure boderItemContainer = (org.eclipse.draw2d.IFigure) figure.getChildren().get(1);
			((org.eclipse.draw2d.IFigure) boderItemContainer.getChildren().get(0))
					.setVisible(false);

			return null;
		}

		de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer r = self
				.getVisualizer().get(0);
		String dslRenderingString = r.getValueForKey("DSLRendering");

		if ("".equals(dslRenderingString))
			return null;
		
		return java.lang.Boolean.parseBoolean(dslRenderingString);
	}
	
	/**
	 * @generated
	 */
	public void updateView()
	{
		«IF self.editPartClassName = 'ConnectionEditPart'
			or self.editPartClassName = 'EntityEditPart'»
		java.lang.Boolean dslRendering = getDSLRenderingValue();
		de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element)resolveSemanticElement();
		
		«IF self.editPartClassName = 'ConnectionEditPart'»
		if (sourceConnections != null){
			//Roles need to be updated
			for (java.lang.Object ep : sourceConnections)
				if (ep instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.edit.parts.RoleEditPart)
					((de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.edit.parts.RoleEditPart)ep).updateView();
		}
		«ENDIF»
		
		if (dslRendering != null && dslRendering == true)
		{
			«IF self.editPartClassName = 'ConnectionEditPart'»  
			toggle();
			«ELSE»
			updateDSL();
			«ENDIF»
			
			return;
		}
		«ENDIF»
	
		«IF self.editPartClassName = 'ConnectionEditPart'
			or self.editPartClassName = 'EntityEditPart'»
		de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject c = (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject)resolveSemanticElement();
		«ENDIF»
		
		«IF not(self.editPartClassName='EntityEditPart'
			or self.editPartClassName = 'ComplementEditPart'
			or self.editPartClassName = 'EqualityEditPart'
			or self.editPartClassName = 'InversionEditPart')»
		java.lang.Boolean toggleValue = getToggleValue();
		
		//We do toggle the connection
		if (toggleValue != null)
			toggle();
		«ENDIF»
		
		«IF self.editPartClassName = 'ConnectionEditPart'»
		//We can do elide as long as a connection is not toggled
		if(toggleValue == null || toggleValue == false)
			doElide();
		«ELSEIF self.editPartClassName = 'EntityEditPart'»
		doElide();
		«ENDIF»
		
		«IF self.editPartClassName = 'ConnectionEditPart'»
		//We can change expressed as long as connection is not elided and not toggled
		if (!c.isElided() && (toggleValue == null || toggleValue == false))
			setExpressedVisualState();
		«ELSEIF self.editPartClassName = 'EntityEditPart'»
		//We can change expressed as long as connection is not elided and not toggled
		if (!c.isElided())
			setExpressedVisualState();
		«ELSEIF self.editPartClassName = 'ComplementEditPart'
			or self.editPartClassName = 'EqualityEditPart'
			or self.editPartClassName = 'InversionEditPart'»
		setExpressedVisualState();
		«ELSE»
		//We can change expressed as long as connection is not elided and not toggled
		if ((toggleValue == null || toggleValue == false))
			setExpressedVisualState();
		«ENDIF»
	}
	«IF self.editPartClassName = 'EntityEditPart'»
	/**
	 * @generated
	 */
	public void updateDSL() {
		
		de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element)resolveSemanticElement();
		
		de.uni_mannheim.informatik.swt.plm.workbench.interfaces.IVisualModelToFigureTransformator tranformator = null;
		
		try {
			tranformator = de.uni_mannheim.informatik.swt.plm.workbench.ExtensionPointService.Instance().getActiveVisualizationService();
		} catch (org.eclipse.core.runtime.CoreException e) {
			e.printStackTrace();
		}
		
		de.uni_mannheim.informatik.swt.models.plm.visualization.DSLVisualizer dslVisualizer = tranformator.findDSLVisualizerForElement(self);
		
		if (dslVisualizer == null)
			return;
		
		org.eclipse.draw2d.IFigure customFigure = tranformator.run(dslVisualizer);
		
		//It is important to only take the content of the DefaultSizeNode and 
		//BorderItemContainer. Everything else will break the diagram
		
		org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure sourceDFN = (org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure)figure.getChildren().get(0); 
		org.eclipse.gmf.runtime.diagram.ui.internal.figures.BorderItemContainerFigure sourceBICF = (org.eclipse.gmf.runtime.diagram.ui.internal.figures.BorderItemContainerFigure)figure.getChildren().get(1); 
		
		//Clear the DefaultSizeNodeFigure children
		sourceDFN.getChildren().clear();
		//Clear the BorderItemContainer children
		sourceBICF.getChildren().clear();
		
		if (customFigure instanceof org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure){
			org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure targetDFN = (org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure)customFigure;  
			
			//Add customFigure children to the DefaultSizeNodeFigure
			for(org.eclipse.draw2d.IFigure f : (java.util.List<org.eclipse.draw2d.IFigure>)targetDFN.getChildren()){
				f.setParent(sourceDFN);
				sourceDFN.add(f);
			}
		} else if (customFigure instanceof org.eclipse.gmf.runtime.diagram.ui.figures.BorderedNodeFigure){
			
			org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure targetDFN = (org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure)customFigure.getChildren().get(0); 
			org.eclipse.gmf.runtime.diagram.ui.internal.figures.BorderItemContainerFigure targetBICF = (org.eclipse.gmf.runtime.diagram.ui.internal.figures.BorderItemContainerFigure)customFigure.getChildren().get(1); 
			
			//Add customFigure children to the DefaultSizeNodeFigure
			for(org.eclipse.draw2d.IFigure f : (java.util.List<org.eclipse.draw2d.IFigure>)targetDFN.getChildren()){
				f.setParent(sourceDFN);
				sourceDFN.add(f);
			}
			
			//Add customFigure children to the BorderItemContainer
			for (org.eclipse.draw2d.IFigure f : (java.util.List<org.eclipse.draw2d.IFigure>)targetBICF.getChildren()){
				de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.edit.parts.ConnectionNameExternalLabelEditPart ep = new de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.edit.parts.ConnectionNameExternalLabelEditPart(
						org.eclipse.gmf.runtime.notation.impl.NotationFactoryImpl.eINSTANCE.createNode());
				de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.edit.parts.ConnectionNameExternalLabelEditPart.ConnectionNameExternalLabelFigure borderFig = (de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.edit.parts.ConnectionNameExternalLabelEditPart.ConnectionNameExternalLabelFigure) ep
						.getFigure();
				borderFig.setText(((org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel) f).getText());
				
				de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator oldLocator = 
						(de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator) (f.getParent().getLayoutManager().getConstraint(f) instanceof de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator?f.getParent().getLayoutManager().getConstraint(f):null);
				
				de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator newLocator = null;
				
				//We need to do this as the main figure is not right when build up in LMLVisualizer
				if (oldLocator != null
						&& oldLocator instanceof de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator)
				{
					newLocator = new de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator(
							getMainFigure(), oldLocator.getPreferredSideOfParent());
					newLocator.setInitialOffset(oldLocator.getInitialOffset());
				}
				else if (oldLocator == null
						|| !(oldLocator instanceof de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator))
					newLocator = new de.uni_mannheim.informatik.swt.gmf.borders.CenteredBorderItemLocator(
							getMainFigure(), org.eclipse.draw2d.PositionConstants.SOUTH);
				
				sourceBICF.add(borderFig, newLocator);
			}
		}
	}
	«ENDIF»
«ENDDEFINE»

«DEFINE getToggleValue FOR gmfgen::GenNode»
	/**
	 * 
	 * @return null if no toggeling infotmation is available, else true or false
	 *
	 * @generated
	 */
	private Boolean getToggleValue()
	{
		//boolean collapse = false;
		
		//********************************************************
		//Find the LMLVisualizer attached to this element 
		//********************************************************
		de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element) this
				.resolveSemanticElement();

		//No rendering information found => all Connection remains expanded
		if (self.getVisualizer().size() == 0) {
			//Hide external name label
			org.eclipse.draw2d.IFigure boderItemContainer = (org.eclipse.draw2d.IFigure) figure.getChildren().get(1);
			((org.eclipse.draw2d.IFigure) boderItemContainer.getChildren().get(0))
					.setVisible(false);

			return null;
		}
		
		de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer r = self.getVisualizer().get(0);
		String collapsedString = r.getValueForKey("collapsed");
		
		return java.lang.Boolean.parseBoolean(collapsedString);
	}
«ENDDEFINE»

«DEFINE toggle FOR gmfgen::GenNode»
	
	/**
	 *
	 * Tracks the editPartsToggledState
	 * 
	 * @generated
	 */
	private boolean inToggeledState = false;
	
	/**
	 * This renders the ConnectionEditPart based on information
	 * in the model. Collapsed means that the Connection is rendered as small 
	 * black rectangle. Collapsed means that the Connection will rendered as
	 * hexagon, its default figure.
	 * 
	 * @generated
	 */
	private void toggle() {
		java.lang.Boolean collapse = getToggleValue();
		
		//expand element
		if (collapse == null || !collapse) {

			this.setBackgroundColor(org.eclipse.swt.widgets.Display.getDefault().getSystemColor(
					org.eclipse.swt.SWT.COLOR_WHITE));

			//remove previous shape
			getMainFigure().getChildren().remove(0);
			//add default figure
			getMainFigure().getChildren().add(0, getPrimaryShape());
			
			//Hide external name label
			org.eclipse.draw2d.IFigure boderItemContainer = (org.eclipse.draw2d.IFigure)figure.getChildren().get(1);
			((org.eclipse.draw2d.IFigure) boderItemContainer.getChildren().get(0))
					.setVisible(false);

			//Allow Resizing
			removeEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE);
			installEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE,
					new org.eclipse.gmf.runtime.diagram.ui.editpolicies.ResizableShapeEditPolicy());

			//When we come from read only context / addNotify the size should be in the
			//notation model
			if (getEditingDomain() instanceof org.eclipse.emf.transaction.impl.InternalTransactionalEditingDomain
					&& 
					//No transaction is running or no readonly transaction is running
					(
						((org.eclipse.emf.transaction.impl.InternalTransactionalEditingDomain) getEditingDomain()).getActiveTransaction() == null
						|| !((org.eclipse.emf.transaction.impl.InternalTransactionalEditingDomain) getEditingDomain()).getActiveTransaction().isReadOnly()
					)
				)
			{
				org.eclipse.gef.Request rr = new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_AUTOSIZE);
				performRequest(rr);
			}
			
			inToggeledState = false;
			
			return;
		}
		//collapse element
		else {
			//**************************************************
			//Create the new figure (Rectangle with black background)
			//**************************************************
			
			//if already toggled -> return
			if (inToggeledState == true)
				return;
			
			org.eclipse.draw2d.geometry.Rectangle rect = (figure.getClientArea() != null) ? figure
					.getClientArea().getCopy() : null;

			((org.eclipse.draw2d.IFigure)figure.getChildren().get(0)).getChildren().clear();

			org.eclipse.draw2d.RectangleFigure rf = new org.eclipse.draw2d.RectangleFigure();

			rf.setBackgroundColor(org.eclipse.swt.widgets.Display.getDefault().getSystemColor(
					org.eclipse.swt.SWT.COLOR_BLACK));
			rf.setBorder(new org.eclipse.draw2d.LineBorder(org.eclipse.ui.PlatformUI.getWorkbench().getDisplay().getSystemColor(org.eclipse.swt.SWT.COLOR_WHITE), 2));	
			
			getMainFigure().getChildren().add(0, rf);
			rf.setParent(getMainFigure());

			//Hide external name label
			org.eclipse.draw2d.IFigure boderItemContainer = (org.eclipse.draw2d.IFigure) figure.getChildren().get(1);
			((org.eclipse.draw2d.IFigure) boderItemContainer.getChildren().get(0)).setVisible(true);

			//A client rectangle existed
			if (rect != null
					&& (rect.width != 0 && rect.height != 0 && rect.x != 0 && rect.y != 0)) {
				cachedSize = rect.getCopy().getSize();
				rect.setSize(8, 8);
				org.eclipse.gmf.runtime.diagram.ui.commands.SetBoundsCommand sbc = new org.eclipse.gmf.runtime.diagram.ui.commands.SetBoundsCommand(
						this.getEditingDomain(), "change size",
						new org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter((org.eclipse.gmf.runtime.notation.View) this.getModel()), rect);
				getEditDomain().getCommandStack().execute(
						new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(sbc));
			}
			//A client rectangle does not exist -> called from activate
			else {
				rf.setSize(8, 8);
			}

			removeEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE);
			installEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE,
					new org.eclipse.gmf.runtime.diagram.ui.editpolicies.NonResizableEditPolicyEx());
					
			inToggeledState = true;
		}
	}
«ENDDEFINE»

«DEFINE addNotify FOR gmfgen::GenNode»
	/**
	 * @generated
	 */
	@Override
	public void addNotify() {
		super.addNotify();

		//Entity EditParts do not have a outer BorderItemContainer in contrast
		//to Connections etc. as those have external labels
				
		updateView();
	}
«ENDDEFINE»

«DEFINE setExpressedVisualState FOR gmfgen::GenNode»
	/**
	 * @generated
	 */
	private org.eclipse.draw2d.geometry.Dimension cachedSize = null;
	
	/**
	 * Sets the figure to visually expressed or computed. Depending on the expressed
	 * value.
	 * 
	 * @generated
	 */
	private void setExpressedVisualState() {
		
		org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart parent = (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart)getParent();
		de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element) resolveSemanticElement();

		//Check is visible
		if (parent.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)
		{
			de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer container = (de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)parent.resolveSemanticElement();
			if ((container.getOrigin().equalsIgnoreCase("computed") && self.isExpressed())
					|| (container.getOrigin().equalsIgnoreCase("expressed") && !self.isExpressed()))
			{
				if (org.eclipse.gmf.runtime.diagram.ui.util.EditPartUtil.isWriteTransactionInProgress(this, true, true))
				{
					getNotationView().setVisible(false);
				}
			}
		}
		else
		{
			if (org.eclipse.gmf.runtime.diagram.ui.util.EditPartUtil.isWriteTransactionInProgress(this, true, true))
			{
				getNotationView().setVisible(true);
			}
		}
		
		if (self.isExpressed()) {
			«IF self.editPartClassName = 'EntityEditPart'
				or self.editPartClassName = 'ComplementEditPart'
				or self.editPartClassName = 'EqualityEditPart'
				or self.editPartClassName = 'InversionEditPart'»
			getPrimaryShape().setLineStyle(org.eclipse.swt.SWT.LINE_SOLID);
			«ELSE»
			getPrimaryShape().setLineStyle(org.eclipse.swt.SWT.LINE_SOLID);
			«ENDIF»
		} else {
			«IF self.editPartClassName = 'EntityEditPart'
				or self.editPartClassName = 'ComplementEditPart'
				or self.editPartClassName = 'EqualityEditPart'
				or self.editPartClassName = 'InversionEditPart'»
			getPrimaryShape().setLineStyle(org.eclipse.swt.SWT.LINE_CUSTOM);
			getPrimaryShape().setLineDash(new float[] { 10 });
			«ELSE»
			getPrimaryShape().setLineStyle(org.eclipse.swt.SWT.LINE_CUSTOM);
			getPrimaryShape().setLineDash(new float[] { 10 });
			«ENDIF»
		}
	}
«ENDDEFINE»

«DEFINE handleNotificationEventForAttribute FOR gmfgen::GenNode»
	/**
	 * @generated
	 */
	@Override
	protected void handleNotificationEvent(org.eclipse.emf.common.notify.Notification notification) {
		super.handleNotificationEvent(notification);

		if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Feature 
				&& ((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("expressed"))
		{
			org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart parent = (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart)getParent();
			de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element) resolveSemanticElement();
		
			//Check is visible
			if (parent.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)
			{
				de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer container = (de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)parent.resolveSemanticElement();
				if ((container.getOrigin().equalsIgnoreCase("computed") && self.isExpressed())
						|| (container.getOrigin().equalsIgnoreCase("expressed") && !self.isExpressed()))
				{
					getNotationView().setVisible(false);
				}
			}
			else
			{
				getNotationView().setVisible(true);
			}
				
			de.uni_mannheim.informatik.swt.models.plm.PLM.Feature f = (de.uni_mannheim.informatik.swt.models.plm.PLM.Feature)resolveSemanticElement();
			if (f.isExpressed())
			{
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setItalic(false);
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setFontColor(0);
			}
			else
			{
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setItalic(true);
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setFontColor(org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities.colorToInteger(org.eclipse.gmf.runtime.diagram.ui.figures.DiagramColorConstants.diagramGray));
			}
		}
		else if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Feature
				&& ((org.eclipse.emf.ecore.EStructuralFeature) notification.getFeature()).getName().equals("elided")) {

			de.uni_mannheim.informatik.swt.models.plm.PLM.Feature f = (de.uni_mannheim.informatik.swt.models.plm.PLM.Feature) resolveSemanticElement();
			if (f.isElided()) {
				//hide all other labels
				for (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart editPart : (java.util.List<org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart>)children)
				{
					if (editPart == children.get(0))
						continue;
					((org.eclipse.gmf.runtime.notation.DecorationNode) editPart.getNotationView()).setVisible(false);
				}
				
				performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
				
				//Set the name label to "..."
				((org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart)children.get(0)).setLabelText("...");
			} else {
				//hide all other labels
				for (org.eclipse.gmf.runtime.notation.DecorationNode view : (java.util.List<org.eclipse.gmf.runtime.notation.DecorationNode>)getNotationView().getChildren())
				{
					view.setVisible(true);
				}
				
				performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
				
				((org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart)children.get(0)).setLabelText(f.getName());
			}
		}

		«IF self.editPartClassName = 'AttributeEditPart'»
		//***********************************************************
		//Update Entities on field change (for rendering)
		//***********************************************************
//		if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Field) {
//			org.eclipse.emf.ecore.EObject field = (org.eclipse.emf.ecore.EObject) notification.getNotifier();
//			org.eclipse.emf.ecore.EObject container = field.eContainer();

			//Only Entyties are used to store rendering information
//			if (container instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer) {
				//Get all Entities that reference this Entity as LMLVisualizer
//				java.util.Collection<org.eclipse.emf.ecore.EObject> LMLVisualizerReferencere = org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil
//						.getReferencers(
//								container,
//								new org.eclipse.emf.ecore.EReference[] { de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.eINSTANCE
//										.getElement_LMLVisualizer() });

//				for (org.eclipse.emf.ecore.EObject obj : LMLVisualizerReferencere) {
//					org.eclipse.ui.IEditorPart editorPart = org.eclipse.ui.PlatformUI.getWorkbench()
//							.getActiveWorkbenchWindow().getActivePage()
//							.getActiveEditor();
					//If no PLM Diagram is opened we want to do nothing
//					if (!(editorPart instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor))
//						return;
//					de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor plmEditor = (de.uni_mannheim.informatik.swt.models.plm.PLM.diagram.part.PLMDiagramEditor) editorPart;
//					org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart node =
//						(org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart)plmEditor.getDiagramGraphicalViewer().findEditPartsForElement(org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getProxyID(obj), org.eclipse.gef.NodeEditPart.class).get(0);
					
//					org.eclipse.gef.Request refreshRequest = new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH);
//					node.performRequest(refreshRequest);
//				}
//			}
//		}
		«ENDIF»
	}
«ENDDEFINE»

«DEFINE handleNotificationEventForMethod FOR gmfgen::GenNode»
	/**
	 * @generated
	 */
	@Override
	protected void handleNotificationEvent(org.eclipse.emf.common.notify.Notification notification) {
		super.handleNotificationEvent(notification);

		if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Feature 
				&& ((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("expressed"))
		{
			org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart parent = (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart)getParent();
			de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element) resolveSemanticElement();
			
			//Check is visible
			if (parent.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)
			{
				de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer container = (de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)parent.resolveSemanticElement();
				if ((container.getOrigin().equalsIgnoreCase("computed") && self.isExpressed())
						|| (container.getOrigin().equalsIgnoreCase("expressed") && !self.isExpressed()))
				{
					getNotationView().setVisible(false);
				}
			}
			else
			{
				getNotationView().setVisible(true);
			}
			
			de.uni_mannheim.informatik.swt.models.plm.PLM.Feature f = (de.uni_mannheim.informatik.swt.models.plm.PLM.Feature)resolveSemanticElement();
			if (f.isExpressed())
			{
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setItalic(false);
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setFontColor(0);
			}
			else
			{
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setItalic(true);
				((org.eclipse.gmf.runtime.notation.Shape)this.getNotationView()).setFontColor(org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities.colorToInteger(org.eclipse.gmf.runtime.diagram.ui.figures.DiagramColorConstants.diagramGray));
			}
		}
	}
«ENDDEFINE»

«DEFINE handleNotificationEventForModel FOR gmfgen::GenNode»
	/**
	 * @generated
	 */
	@Override
	protected void handleNotificationEvent(org.eclipse.emf.common.notify.Notification notification) 
	{
		super.handleNotificationEvent(notification);
		
		if(notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Model
			&& ((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("content"))
		{
			if (notification.getNewValue() != null)
			{
				de.uni_mannheim.informatik.swt.models.plm.PLM.Model m = (de.uni_mannheim.informatik.swt.models.plm.PLM.Model)notification.getNotifier();
				
				if (notification.getNewValue() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject)
				{
					de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject c = (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject)notification.getNewValue();
					de.uni_mannheim.informatik.swt.models.plm.PLM.Ontology ont = (de.uni_mannheim.informatik.swt.models.plm.PLM.Ontology)m.eContainer();
					c.setLevel(ont.getContent().indexOf(m));
				}
			}
		}
		if(notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Model
			&& ((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("expressed"))
		{
			org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart parent = (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart)getParent();
			de.uni_mannheim.informatik.swt.models.plm.PLM.Element self = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element) resolveSemanticElement();
			
			//Check is visible
			if (parent.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)
			{
				de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer container = (de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer)parent.resolveSemanticElement();
				if ((container.getOrigin().equalsIgnoreCase("computed") && self.isExpressed())
						|| (container.getOrigin().equalsIgnoreCase("expressed") && !self.isExpressed()))
				{
					getNotationView().setVisible(false);
				}
			}
			else
			{
				getNotationView().setVisible(true);
			}
		}
		else if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Model && 
				((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("LMLVisualizersShown"))
		{
		 	«EXPAND showHideLMLVisualizers FOR self»
		}
		else if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Model
			&& ((org.eclipse.emf.ecore.EStructuralFeature) notification.getFeature()).getName()
					.equals("origin")) 
		{
			«EXPAND ShowHideExpressed FOR self»
		}
		else if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Model
				&& ((org.eclipse.emf.ecore.EStructuralFeature) notification.getFeature()).getName()
						.equals("completness")) {
			de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject[] clabjects = new de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject[] {};
			de.uni_mannheim.informatik.swt.models.plm.PLM.Model model = (de.uni_mannheim.informatik.swt.models.plm.PLM.Model) resolveSemanticElement();

			//find all LMLVisualizers in the model
			org.eclipse.ocl.ecore.OCL ocl = org.eclipse.ocl.ecore.OCL
					.newInstance();
			org.eclipse.ocl.helper.OCLHelper<org.eclipse.emf.ecore.EClassifier, ?, ?, org.eclipse.ocl.ecore.Constraint> helper = ocl
					.createOCLHelper();
			helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.MODEL);

			try {
				org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper
						.createQuery("self.content->select(c | c.oclIsKindOf(Clabject))");

				clabjects = ((java.util.HashSet<de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject>) ocl
						.evaluate(resolveSemanticElement(), q))
						.toArray(new de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject[] {});
			} catch (org.eclipse.ocl.ParserException e) {
				e.printStackTrace();
			}

			//find the notational elements for the LMLVisualizers
			for (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject c : clabjects) {
				org.eclipse.emf.common.util.TreeIterator<org.eclipse.emf.ecore.EObject> iter = (getNotationView().eAllContents());

				while (iter.hasNext()) {
					org.eclipse.emf.ecore.EObject obj = iter.next();

					if (obj instanceof org.eclipse.gmf.runtime.notation.Node) {
						org.eclipse.gmf.runtime.notation.Node s = (org.eclipse.gmf.runtime.notation.Node) obj;

						if (s.getElement() == c) {
							if (model.getCompletness().equalsIgnoreCase(
									"NoElision")
									&& c.isElided())
								s.setVisible(false);
							else
								s.setVisible(true);

							break;
						}
					}
				}
			}

			performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
		}
	}
«ENDDEFINE»

«/* Manages to show hide LMLVisualizers when setting LMLVisualizersShown trait */»
«DEFINE showHideLMLVisualizers FOR gmfgen::GenNode»
			de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer container = (de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer) notification.getNotifier();

			de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer[] LMLVisualizers = new de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer[] {};

			//find all LMLVisualizers in the model
			org.eclipse.ocl.ecore.OCL ocl = org.eclipse.ocl.ecore.OCL.newInstance();
			org.eclipse.ocl.helper.OCLHelper<org.eclipse.emf.ecore.EClassifier, ?, ?, org.eclipse.ocl.ecore.Constraint> helper = ocl.createOCLHelper();
			
			«IF self.editPartClassName = 'ModelEditPart'»
			helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.MODEL);
			«ELSEIF self.editPartClassName = 'OntologyEditPart'»
			helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.ONTOLOGY);
			«ELSEIF self.editPartClassName = 'EntityEditPart'»
			helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.ENTITY);
			«ELSEIF self.editPartClassName = 'ConnectionEditPart'»
			helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.CONNECTION);
			«ENDIF»
			
			try 
			{
			    «IF self.editPartClassName = 'ModelEditPart'»
				org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.content->collect(c | c.LMLVisualizer)");
				«ELSEIF self.editPartClassName = 'OntologyEditPart'»
				org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.content->collect(c | c.LMLVisualizer)->union(self.LMLVisualizer->collect(r|r))");
				«ELSEIF self.editPartClassName = 'EntityEditPart'»
				org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.feature->collect(f | f.LMLVisualizer)");
				«ELSEIF self.editPartClassName = 'ConnectionEditPart'»
				org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.feature->collect(f | f.LMLVisualizer)");
				«ENDIF»
				
				LMLVisualizers = ((java.util.ArrayList<de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer>) ocl.evaluate(resolveSemanticElement(), q)).toArray(new de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer[] {});
			}
			catch (org.eclipse.ocl.ParserException e) 
			{
				e.printStackTrace();
			}
			
			//find the notational elements for the LMLVisualizers
			for(de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer r : LMLVisualizers)
			{
				org.eclipse.emf.common.util.TreeIterator<org.eclipse.emf.ecore.EObject> iter = (getNotationView().eAllContents());
				
				while (iter.hasNext())
				{
					org.eclipse.emf.ecore.EObject obj = iter.next();
					
					if (obj instanceof org.eclipse.gmf.runtime.notation.Node)
					{
						org.eclipse.gmf.runtime.notation.Node n = (org.eclipse.gmf.runtime.notation.Node)obj;
						
						if (n.getElement() == r)
						{
							if (container.getVisualizersShown().equalsIgnoreCase("none"))
								n.setVisible(false);
							else
								n.setVisible(true);
							
							break;
						}
					}
				}
			}
			
			performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));

«ENDDEFINE»

«/*Manages to show hide expressed when setting origin trait */»
«DEFINE ShowHideExpressed FOR gmfgen::GenNode»
	de.uni_mannheim.informatik.swt.models.plm.PLM.Element[] elements = new de.uni_mannheim.informatik.swt.models.plm.PLM.Element[] {};
	de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer container = (de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer) resolveSemanticElement();
	
	//find all LMLVisualizers in the model
	org.eclipse.ocl.ecore.OCL ocl = org.eclipse.ocl.ecore.OCL
			.newInstance();
	org.eclipse.ocl.helper.OCLHelper<org.eclipse.emf.ecore.EClassifier, ?, ?, org.eclipse.ocl.ecore.Constraint> helper = ocl
			.createOCLHelper();
	
	«IF self.editPartClassName = 'ModelEditPart'»
	helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.MODEL);
	«ELSEIF self.editPartClassName = 'OntologyEditPart'»
	helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.ONTOLOGY);
	«ELSEIF self.editPartClassName = 'EntityEditPart'»
	helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.ENTITY);
	«ELSEIF self.editPartClassName = 'ConnectionEditPart'»
	helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.CONNECTION);
	«ENDIF»

	try {	
		«IF self.editPartClassName = 'ModelEditPart'»
		org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.content");
		«ELSEIF self.editPartClassName = 'OntologyEditPart'»
		org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.content");
		«ELSEIF self.editPartClassName = 'EntityEditPart'»
		org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.feature");
		«ELSEIF self.editPartClassName = 'ConnectionEditPart'»
		org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("self.feature");
		«ENDIF»
		
		elements = ((java.util.HashSet<de.uni_mannheim.informatik.swt.models.plm.PLM.Element>) ocl
				.evaluate(resolveSemanticElement(), q))
				.toArray(new de.uni_mannheim.informatik.swt.models.plm.PLM.Element[] {});
	} catch (org.eclipse.ocl.ParserException e) {
		e.printStackTrace();
	}

	//find the notational elements for the LMLVisualizers
	for (de.uni_mannheim.informatik.swt.models.plm.PLM.Element e : elements) {
		org.eclipse.emf.common.util.TreeIterator<org.eclipse.emf.ecore.EObject> iter = (getNotationView().eAllContents());

		while (iter.hasNext()) {
			org.eclipse.emf.ecore.EObject obj = iter.next();

			if (obj instanceof org.eclipse.gmf.runtime.notation.Node) {
				org.eclipse.gmf.runtime.notation.Node s = (org.eclipse.gmf.runtime.notation.Node) obj;

				if (s.getElement() == e) {
					if (container.getOrigin().equalsIgnoreCase("expressed") && e.isExpressed()
							|| container.getOrigin().equalsIgnoreCase("computed") && !e.isExpressed()
							|| container.getOrigin().equalsIgnoreCase("all"))
						s.setVisible(true);
					else
						s.setVisible(false);

					break;
				}
			}
		}
	}
			
	performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
«ENDDEFINE»

«DEFINE handleNotificationEventForOntology FOR gmfgen::GenNode»
	/**
	 * Inform all LMLVisualizers to set their view state
	 * 
	 * @generated
	 */
	@Override
	protected void handleNotificationEvent(org.eclipse.emf.common.notify.Notification notification) {
		super.handleNotificationEvent(notification);
		
		if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer && 
				((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("LMLVisualizersShown"))
		{
			«EXPAND showHideLMLVisualizers FOR self»
		}
		else if (notification.getNotifier() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.VisualizationContainer && 
				((org.eclipse.emf.ecore.EStructuralFeature)notification.getFeature()).getName().equals("origin")) 
		{
			«EXPAND ShowHideExpressed FOR self»
		}
	}
«ENDDEFINE»

«DEFINE doElide FOR gmfgen::GenNode»
	/**
	 * Elides the Entity depending on the elided attribute
	 * 
	 * @generated
	 */
	private void doElide() {

		de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject clab = (de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject) resolveSemanticElement();

		//The figure
		org.eclipse.draw2d.IFigure defaultSizeNodeFigure = getMainFigure();
		//the container that contains the border items
		org.eclipse.draw2d.IFigure borderItemContainer = (org.eclipse.draw2d.IFigure) figure.getChildren().get(1);
		
		//Elide and hide if model.complteness = NoElision
		if (clab.isElided()) {

			org.eclipse.draw2d.geometry.Rectangle rect = figure.getClientArea().getCopy();
			
			defaultSizeNodeFigure.getChildren().remove(0);
			
			//Set up the new figure for the elided node
			org.eclipse.draw2d.RectangleFigure rf = new org.eclipse.draw2d.RectangleFigure();
			rf.setSize(new org.eclipse.draw2d.geometry.Dimension(30, 15));
			
			rf.setLayoutManager(new org.eclipse.draw2d.ToolbarLayout());
			rf.setOutline(false);

			org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel wl = new org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel();
			wl.setText("...");
			org.eclipse.swt.graphics.Color black = org.eclipse.ui.PlatformUI.getWorkbench().getDisplay().getCurrent().getSystemColor(org.eclipse.swt.SWT.COLOR_BLACK);
			wl.setForegroundColor(black);

			rf.add(wl);
			defaultSizeNodeFigure.getChildren().add(0, rf);
			rf.setParent(defaultSizeNodeFigure);
			
			//On Startup the size is saved in the notational model
			if (org.eclipse.gmf.runtime.diagram.ui.util.EditPartUtil.isWriteTransactionInProgress(this, true, true)) {
				//Resize the elided node
				rect.setSize((cachedSize != null) ? cachedSize : new org.eclipse.draw2d.geometry.Dimension(
						10, 10));
				org.eclipse.gmf.runtime.diagram.ui.commands.SetBoundsCommand sbc = new org.eclipse.gmf.runtime.diagram.ui.commands.SetBoundsCommand(
						this.getEditingDomain(), "change size",
						new org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter((org.eclipse.gmf.runtime.notation.View) this.getModel()), rect);
				getEditDomain().getCommandStack().execute(
						new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(sbc));
			}

			//Dash all lines from to the elided element
			if (targetConnections != null) {
				for (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart link : (java.util.List<org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart>) targetConnections) {
					if (!(link.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Classification)){
						((org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx) link.getFigure())
								.setLineStyle(org.eclipse.swt.SWT.LINE_CUSTOM);
						((org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx) link.getFigure())
								.setLineDash(new int[] { 10 });
					}
				}
			} else if (sourceConnections != null) {
				for (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart link : (java.util.List<org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart>) sourceConnections) {
						if (!(link.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Classification)){
						((org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx) link.getFigure())
								.setLineStyle(org.eclipse.swt.SWT.LINE_CUSTOM);
						((org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx) link.getFigure())
								.setLineDash(new int[] { 10 });
					}
				}
			}

			removeEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE);
			installEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE,
					new org.eclipse.gmf.runtime.diagram.ui.editpolicies.NonResizableEditPolicyEx());

			performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));

			if (clab.eContainer() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Model 
					&& ((de.uni_mannheim.informatik.swt.models.plm.PLM.Model)clab.eContainer()).getCompletness().equalsIgnoreCase("noelision"))
				getNotationView().setVisible(false);
		}
		//We only need to revert the elision if we have done it when the editor was open
		else
		{
			defaultSizeNodeFigure.getChildren().remove(0);
			defaultSizeNodeFigure.getChildren().add(0, getPrimaryShape());
			getPrimaryShape().setParent(defaultSizeNodeFigure);

			//We cannot execute commands in read only context
			if (org.eclipse.gmf.runtime.diagram.ui.util.EditPartUtil.isWriteTransactionInProgress(this, true, true))
			{
				org.eclipse.gef.Request rr = new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_AUTOSIZE);
				performRequest(rr);
			}
			
			//Make all lines from to the elided element solid
			if (targetConnections != null) {
				for (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart link : (java.util.List<org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart>) targetConnections) {
					if (!(link.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Classification))
						((org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx) link.getFigure())
							.setLineStyle(org.eclipse.swt.SWT.LINE_SOLID);
				}
			} else if (sourceConnections != null) {
				for (org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart link : (java.util.List<org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart>) sourceConnections) {
					if (!(link.resolveSemanticElement() instanceof de.uni_mannheim.informatik.swt.models.plm.PLM.Classification))
						((org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx) link.getFigure())
							.setLineStyle(org.eclipse.swt.SWT.LINE_SOLID);
				}
			}

			removeEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE);
			installEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE,
					new org.eclipse.gmf.runtime.diagram.ui.editpolicies.ResizableShapeEditPolicy());
					
			performRequest(new org.eclipse.gef.Request(org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants.REQ_REFRESH));
		}
	
		«IF self.editPartClassName = 'ConnectionEditPart'»
		//Hide the outer label
		((org.eclipse.draw2d.IFigure) borderItemContainer.getChildren().get(0)).setVisible(false);
		«ENDIF»
	}
«ENDDEFINE»

«DEFINE registerToHandleNotificationForChildren FOR gmfgen::GenNode»
	/**
	 * Registers the Edipart to fire handleNotification on changes
	 * in LMLVisualizer.
	 *
	 * BUG: Only runs on EditPartCrearion. Items which are added Afterwards are not
	 * listened to.
	 * 
	 * @generated
	 */
	@Override
	protected void addSemanticListeners() {
		super.addSemanticListeners();
		
		de.uni_mannheim.informatik.swt.models.plm.PLM.Element e = (de.uni_mannheim.informatik.swt.models.plm.PLM.Element) resolveSemanticElement();
		
		//Register for listening to LMLVisualizer changes
		for (de.uni_mannheim.informatik.swt.models.plm.PLM.LMLVisualizer v : e.getVisualizer())
			addListenerFilter(v.toString().substring(0, v.toString().indexOf(" ")), this, v);
		
		«IF self.editPartClassName = 'ConnectionEditPart'
				or self.editPartClassName = 'EntityEditPart'»
		//Register to listen for feature changes
		for (de.uni_mannheim.informatik.swt.models.plm.PLM.Feature f : ((de.uni_mannheim.informatik.swt.models.plm.PLM.Clabject)e).getFeature())
			addListenerFilter(f.toString().substring(0, f.toString().indexOf(" ")), this, f);
		«ENDIF»
	}
«ENDDEFINE»