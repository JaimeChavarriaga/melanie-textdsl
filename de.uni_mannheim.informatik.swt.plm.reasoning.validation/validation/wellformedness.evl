context Ontology {
	constraint notComputedOrIrrelevant {
		check: self.expressed and self.relevant
		message: 'Ontologies cannot be computed or irrelevant'
		fix {
			title: 'Set expressed and relevant to true'
			do {
              self.expressed := true;
              self.relevant := true;
          }
		}
	}
}

context Clabject {

	constraint potencyNotNegative {
		check: self.potency > -2
		message: '\'' + self.name + '\' potency cannot be negative'
		fix {
			title: 'Set potency to *'
			do {self.potency := -1;}
		}
		fix {
			title: 'Compute the potency based on types'
			do {
				--tbd
			}
		}
	}
	
	constraint levelNotNegative {
		check: self.level > -1
		message: '\'' + self.name + '\' level cannot be negative'
		fix {
			title: 'Set the level to the level of the model.'
			do {self.level := self.getModel().getLevel();}
		}
	}
	
	constraint levelNotModel {
		guard: self.level > -1
		check: self.level = self.getModel().getLevel()
		message: '\'' + self.name + '\' level does not match level of the containing model'
		fix {
			title: 'Set the level to the level of the containing model'
			do {self.level := self.getModel().getLevel();}
		}
	}
	
	constraint featureNameUnique {
		guard: self.feature->size() > 0
		check {
		 var names =  self.feature->collect(f|f.name);
		 return names->forAll(n|names.count(n) = 1);
		}
		message: '\''+ self.name + '\' defines features with duplicate names'
	}
	
	
	constraint visualizerDurability {
		guard: self.potency > -2
		check: (self.potency = -1) or (self.visualizer->forAll(v|v.durability <= self.potency))
		message: '\'' + self.name + '\' has a visualizer of incorrect durability'
		fix {
			title: 'Set all mismatching visualizer\'s durability to ' + self.potency
			do {
				for (v in self.visualizer->select(v|v.durability > self.potency)) {
					v.durability := self.potency;
				}
			}
		}
	}
	
	constraint onlyOneClassification {
		check: self.getModelClassificationsAsInstance()->select(inst|inst.kind = ClassificationKind#instantiation)->size() <= 1
		message: 'There can be only one classification per Clabject. Change kind of/remove redundant Classification(s).'
	}
}

context Entity{
	critique noNameButPotencyGreaterZero{
		check: (self.name.isUndefined() or self.name = '') implies (self.potency = 0)
		message: 'Anonymus types can cause problems with the "DSL Element"" palete'
	}
}

context Feature {
	constraint durabilityNotNegative {
		check: self.durability > -2
		message: 'The durability of feature \'' + self.name + '\' cannot be negative'
		fix {
			title: 'Set durability to the potency of the Clabject'
			do{self.durability := self.getClabject().potency;}
		} 
	}
	
	constraint visualizerDurability {
		guard: self.durability > -2
		check: (self.durability = -1) or (self.visualizer->forAll(v|v.durability <= self.durability))
		message: '\'' + self.name + '\' has a visualizer of incorrect durability'
		fix {
			title: 'Set all mismatching visualizer\'s durability to ' + self.durability
			do {
				for (v in self.visualizer->select(v|v.durability > self.durability)) {
					v.durability := self.durability;
				}
			}
		}
	}
}

context Attribute {
	
	constraint mutabilityNotHigherDurability {
		check: (self.durability = -1) or (self.mutability <= self.durability)
		message: 'The mutability of feature \'' + self.name + '\' cannot be higher than the durability of the faeture'
		fix {
			title: 'Set the feature\'s mutability to its the durability'
			do {self.mutability := self.durability;}
		}
	}
	
	constraint datatypeValueMismatch {
	-- don't know how to parse the value string or to do something and check for an exception
		check: (self.datatype = 'String' or self.datatype = "string") implies true 
		message: self.name + '.datatype does not match to the value ' + self.datatype + " <> " + self.value
		fix {
			title: 'Adjust the type.'
			do {}
		}
	}
}

context LMLVisualizer {
	constraint durabilityNotNegative {
		check: self.durability > -2
		message: 'The durability of a visualizer cannot be negative'
		fix {
			--guard: self.getElement().oclIsKindOf(Feature)
			title: 'Compute the durability from the visualizer'
			do {
				var typeName = self.getElement().oclAsType(ecore::EObject).eClass().name;
				var el = self.getElement();
				
				if (typeName = 'Attribute' or typeName = 'Method') {
					self.durability := el.durability;
				} else if (typeName = 'Entity' or typeName = 'Connection') {
					self.durability := el.potency;
				} else {
					self.durability := 0;
				}
			}
		}
	}
}

context LogicalElement {
	constraint visualizerDurabilityZero {
		check: self.visualizer->forAll(v|v.durability = 0)
		message: 'The durability of a visualizer of a \'' + self.getElement().oclAsType(ecore::EObject).eClass().name + '\' has to be 0'
		fix {
			title: 'Set the ' + self.getElement().oclAsType(ecore::EObject).eClass().name + '\'s durability to 0'
			do {
				for (v in self.visualizer->select(v|v.durability <> 0)) {
					v.durability := 0;
				}
			}
		}
	}
}

context Element {
	constraint nameNotEmpty {
		check: self.name.size() > 0
		message: 'The name of an element cannot be empty'
	}
}

context Connection {
	constraint roleNameUnique {
		check{
			var names = self.role->select(r | not r.hasDefaultRoleName())->collect(r | r.roleName);
		 	return names->forAll(n|names.count(n) = 1);
		}
		message: 'The role names of connection \'' + self.name + '\' are not unique'
	}

	constraint connectOneLevel {
		check :self.role->asSequence()->forAll(r|r.destination.level = self.level)
		message : 'The Connection \'' + self.name + '\' connects the clabject\'s {'+ self.role->select(r | r.destination.level <> self.level)->collect(r | r.destination.name)->concat(',')  +'} from another level'
	}
	
	constraint notConnectLowerPotency {
		check: self.role->asSequence()->forAll(r|(self.potency = -1 or r.destination.potency = -1) or (r.destination.potency >= self.potency))
		message: 'The Connection \'' + self.name + '\' has participants of lower a potency lower than the connection\'s potency'
		fix {
			title: 'Adjust the potency of the connection to the highest potency of its participants'
			do {
				self.potency := self.role->collect(r | r.destination)->sortedBy(potency)->last().potency;
			}
		}
		fix {
			title: 'Adjust the participant\'s potency to the Connection\'s potency'
			do {
				for (r in self.role->select(r|r.destination.potency < self.potency)) {
					r.destination.potency := self.potency;
				}
			}
		}
	}
	
	constraint multiplicitySanity {
		check: self.role->forAll(r|(r.lower > -2 and r.upper > -2) -- We are not allowed to be negative
											and ((r.lower <= r.upper) -- Not star
													or(r.upper = -1 and r.lower >= 0 )) -- If upper -1 we do not care about lower
									)
		message: '\'' + self.name + '\' has wrong multiplicities. The following must be fullfiled lower <= upper.'
		fix {
			title: 'Adjust the lower multiplicity'
			do {
				println('insertAt not working. Refusing to construct lists');
				--for (rn in self.roleName) {
				--	var index = self.roleName->indexOf(rn);
				--	if (self.getLowerForRoleName(rn)<0) {
				--		self.lower->removeAt(index);
				--		self.lower->insertAt(index, 0);
				--	}
				--	if (self.getLowerForRoleName(rn) > self.getUpperForRoleName(rn) and self.getUpperForRoleName(rn) <> -1) {
				--		self.lower->removeAt(index);
				--		self.lower->insertAt(index, self.getUpperForRoleName(rn));
				--	}
				--}
			}
		}
	}
	
	constraint atLeastTwoRoles{
		guard: Generalization.allInstances()->forAll(g | not g.subtype->contains(self))
		check: self.role->size() > 1
		message: "A not inherited connection does need at least two roles."
	}
}

context Generalization {
		 constraint superAndSubtypesGreaterOne{
			check : (self.subtype->size() > 1 and self.supertype->size() > 1) implies (self.disjoint.isUndefined() and self.complete.isUndefined() and self.intersection.isUndefined())
			message : 'Disjoint, complete and intersection must be null if more than one super AND sub types exist.'
		}
		constraint disjointCompleteMoreThanOneSubType{
			check : (self.disjoint.isDefined() or self.complete.isDefined()) implies (self.supertype->size()  = 1 and self.subtype->size() > 1)
			message: 'MORE than ONE sub AND ONE super type needed if disjoint or complete is set.' 
		}
		constraint intersectionMoreThanOneSuperType{
			check : (self.intersection.isDefined()) implies (self.supertype->size()  > 1 and self.subtype->size() = 1)
			message: 'MORE than ONE super AND ONE sub type needed if intersection is set.' 
		}
		constraint onlyDisjointCompleteSet{
			check: (self.disjoint.isDefined() or self.complete.isDefined()) implies (self.intersection.isUndefined())
			message: 'Complete/disjoint and intersection cannot be set at the same time.'
		}
		constraint onlyIntersectionSet{
			check: (self.intersection.isDefined()) implies (self.disjoint.isUndefined() or self.complete.isUndefined())
			message: 'Complete/disjoint and intersection cannot be set at the same time.'
		}
	}