-- @nsURI MOF=http://www.eclipse.org/emf/2002/Ecore
-- @path plm=/de.uni_mannheim.informatik.swt.models.plm/model/PLM.ecore

--******************************************************************************
--* Copyright (c) 2011 University of Mannheim: Chair for Software Engineering
--* All rights reserved. This program and the accompanying materials
--* are made available under the terms of the Eclipse Public License v1.0
--* which accompanies this distribution, and is available at
--* http://www.eclipse.org/legal/epl-v10.html
--*
--* Contributors:
--*    Ralph Gerbig - initial API and implementation and initial documentation
--*******************************************************************************/

--Regular VM

module mm2mmm;

create OUT:plm from IN:MOF;

---The ontology
helper def : ontology : plm!Ontology = OclUndefined;

---The ROM
helper def : o_0 : plm!Model = OclUndefined;
---The meta-model model
helper def : o_1 : plm!Model = OclUndefined;

helper def : romThing : plm!Entity = OclUndefined;
helper def : romConnection : plm!Connection = OclUndefined;

---Returns the Visualizer attributes that are not trait specific
helper context plm!Element def : getAdditionalVizualizationAttributes : Sequence(String) = 
	if (self.oclIsKindOf(plm!Connection)) then
		Sequence{'collapsed= false', 'ProximityInstantiation= 1', 'DSLRendering= true'}
	else
		if (self.oclIsKindOf(plm!Entity)) then
			Sequence{'ProximityInstantiation= 1', 'DSLRendering= true'}
		else
			if(self.oclIsKindOf(plm!Generalization))then
				Sequence{'collapsed= false'}
			else
				Sequence{''}
			endif
		endif
	endif;

--Sets up the model infrastructure before all other rules are executed
entrypoint rule entry(){
	using {
		--Stores the thing from the ROM
		ROMThing : plm!Entity = OclUndefined;
		--Contains all EClasses that get matched by the matched rules -> Not in referenced model
	}
	to
		t:plm!LMLModel
	do{
		--Create Ontology
		t.name <- MOF!EPackage.allInstancesFrom('MOF')->first().name;
		t.elements <- t.elements->including(thisModule.createOntology());
		
		--Create ROM and meta-model model
		thisModule.ontology.content <- thisModule.ontology.content->append(thisModule.createO_0());
		thisModule.ontology.content <- thisModule.ontology.content->append(thisModule.createO_1());
		
		--Fill ROM
		ROMThing <- thisModule.createROMEntity('Thing');
		thisModule.o_0.content <- thisModule.o_0.content->append(ROMThing)->append(thisModule.createROMConnection('Connection', ROMThing));
		thisModule.romConnection;
		
		--Don't know why this is only returning the referenced EClasses -> It should return all EClasses..
		MOF!EClass.allInstancesFrom('IN')->select(eClass | not eClass.oclIsUndefined())->collect(eClass | thisModule.LazyEClass2Clabject(eClass));
	}
}

unique lazy rule LazyEClass2Clabject{
	from
		s:MOF!EClass
	to
		t:plm!Entity(
			name <- s.name,
			feature <-
					--This can happen when called for parameter creation of methods
					if (not s.oclIsKindOf(MOF!EDataType)) then
						--Already plm mm elemet -> use it -> otherwise create one
						s.eAttributes->collect(a | if (not a.oclIsKindOf(plm!Attribute)) then
												thisModule.LazyEAttribute2Attribute(a)
										else
												a
										endif)->append(
										s.eOperations->collect(o | if (not o.oclIsKindOf(plm!Method)) then
												thisModule.LazyEOperation2Method(o)
										else
												o
										endif))
						else
							Sequence{}
						endif,
			potency <- 1,
			level <- 1
		)
		do{
			--This can happen when called for parameter creation of methods
			if (not s.oclIsKindOf(MOF!EDataType)){
				--Build the inheritance hierarchy
				if (s.eSuperTypes.size() = 1){
					thisModule.createBinaryGeneralization(t, s.eSuperTypes->first());
				}
				if (s.eSuperTypes.size() > 1){
					thisModule.createMultipleGeneralization(t, s.eSuperTypes);
				}
			}
			
			t.visualizer <- Sequence{thisModule.createVisualizer(t)};
			
			thisModule.o_1.content <- thisModule.o_1.content->append(t);
			thisModule.createInstantiationFromO1ToO0(t, thisModule.romThing);
			
			--This can happen when called for parameter creation of methods
			if (not s.oclIsKindOf(MOF!EDataType)){
				s.eAllReferences->collect(s | thisModule.LazyEReference2Connection(s));
			}
			
			t;
		}
}

unique lazy rule LazyEReference2Connection{
	from
		s:MOF!EReference
	to
		t:plm!Connection(
			name <- s.name,
			participant <- Sequence{if (not s.eContainingClass.oclIsKindOf(plm!Entity)) then
												thisModule.LazyEClass2Clabject(s.eContainingClass)
										else
												s.eContainingClass
										endif, 
										if (not s.eReferenceType.oclIsKindOf(plm!Entity)) then
												thisModule.LazyEClass2Clabject(s.eReferenceType)
										else
												s.eReferenceType
										endif},
			potency <- 1,
			level <- 1,
			isNavigable <- Sequence{false, true},
			lower <- Sequence{1, s.lowerBound},
			upper <- Sequence{1, s.upperBound},
			roleName <- Sequence{'',''}
		)
		do{
			t.visualizer <- Sequence{thisModule.createVisualizer(t)};
			thisModule.createInstantiationFromO1ToO0(t, thisModule.romConnection);
			thisModule.o_1.content <- thisModule.o_1.content->append(t);
		}
}

lazy rule LazyEAttribute2Attribute{
	from
		s:MOF!EAttribute
	to
		t:plm!Attribute(
			name <- s.name,
			durability <- 1,
			mutability <- 1,
			datatype <- if (not s.eType.oclIsKindOf(plm!Entity)) then
												thisModule.LazyEClass2Clabject(s.eType)
										else
												s.eType
										endif
		)
	do{
		t.visualizer <- Sequence{thisModule.createVisualizer(t)};
	}
}

lazy rule LazyEOperation2Method{
	from
		s:MOF!EOperation
	to
		t:plm!Method(
			name <- s.name,
			durability <- 1,
			input <- s.eParameters->collect(p | if (not p.oclIsKindOf(plm!Entity)) then
												thisModule.LazyEClass2Clabject(p.eType)
										else
												p
										endif)
		)
	do{
		t.visualizer <- Sequence{thisModule.createVisualizer(t)};
	}
}

rule createOntology() {
	to 
		t : plm!Ontology(
			name <- MOF!EPackage.allInstancesFrom('MOF')->first().name
		)
	do{
		t.visualizer <- Sequence{thisModule.createVisualizer(t)};
		
		thisModule.ontology <- t;
		t;
	}
}

---Creates a Connection for the ROM 
---name = name
rule createROMEntity(name : String){
	to
		t : plm!Entity(
			name <- name,
			potency <- 2
		)
		do{
			t.visualizer <- Sequence{thisModule.createVisualizer(t)};
			
			thisModule.romThing <- t;
			t;
		}
}

---Creates a Connection for the ROM 
---name = name
---participant = participant
rule createROMConnection(name : String, participant : plm!Entity){
	to
		t : plm!Connection(
			name <- name,
			participant <- Sequence{participant, participant},
			lower <- Sequence{0,0},
			upper <- Sequence{-1,-1},
			isNavigable <- Sequence{false, false},
			roleName <- Sequence{'',''},
			potency <- 2
		)
		do{
			t.visualizer <- Sequence{thisModule.createVisualizer(t)};
			
			thisModule.romConnection <- t;
			t;
		}
}

---Creates the ROM
rule createO_0() {
	to 
		t : plm!Model(
			name <- 'O0'
		)
	do{
		t.visualizer <- Sequence{thisModule.createVisualizer(t)};
		
		thisModule.o_0 <- t;
		t;
	}
}

---Creates the model for the meta-model
rule createO_1() {
	to 
		t : plm!Model(
			name <- 'O1'
		)
	do{
		t.visualizer <- Sequence{thisModule.createVisualizer(t)};
		
		thisModule.o_1 <- t;
		t;
	}
}

---Create an instantiation from O1 to O0
---instance = instance
---type = type
unique lazy rule createInstantiationFromO1ToO0{
	from
		instance : plm!Clabject,
		type : plm!Clabject
	to
		t:plm!Instantiation(
			instance <- instance,
			type <- type
		)
	do
	{
		t.visualizer <- Sequence{thisModule.createVisualizer(t)};
		
		thisModule.o_1.content <- thisModule.o_1.content->append(t);
		t;
	}
}

---Creates a BinaryGeneralization
---sub = subtype
---sup = supertype
unique lazy rule createBinaryGeneralization{
	from
		sub:MOF!EClass, 
		sup:MOF!EClass
	to
		t:plm!BinaryGeneralization(
			subtype <- if (not sub.oclIsKindOf(plm!Entity)) then
							thisModule.LazyEClass2Clabject(sub)
						else
							sub
						endif,
			supertype <- if (not sup.oclIsKindOf(plm!Entity)) then
							thisModule.LazyEClass2Clabject(sup)
						else
							sup
						endif
		)
	do{
		t.visualizer <- Sequence{thisModule.createVisualizer(t)};
		
		thisModule.o_1.content <- thisModule.o_1.content->append(t);
		t;
	}
}

---Creates a MultipleGeneralization
---sub = subtype
---sup = supertype
unique lazy rule createMultipleGeneralization{
	from
		sub:MOF!EClass, 
		sup:Sequence(MOF!EClass)
	to
		t:plm!MultipleGeneralization(
			subtype <- if (not sub.oclIsKindOf(plm!Entity)) then
							thisModule.LazyEClass2Clabject(sub)
						else
							sub
						endif,
			supertype <- sup->collect(s | if (not s.oclIsKindOf(plm!Entity)) then
							thisModule.LazyEClass2Clabject(s)
						else
							s
						endif)
		)
		do{
			t.visualizer <- Sequence{thisModule.createVisualizer(t)};
			
			thisModule.o_1.content <- thisModule.o_1.content->append(t);
			
			t;
		}
}

---Creates a visualizer
rule createVisualizer(element:plm!Element)
{
	using {
		eObject:MOF!EObject = element;
	}
	to
		t:plm!Visualizer(
			durability <- 0,
			--Go through all traits + add custom pairs
			attributes <- eObject.eClass().eAllAttributes->collect(a | a.name.concat('= default'))->union(element.getAdditionalVizualizationAttributes)
		)
	do{
		t;
	}
}