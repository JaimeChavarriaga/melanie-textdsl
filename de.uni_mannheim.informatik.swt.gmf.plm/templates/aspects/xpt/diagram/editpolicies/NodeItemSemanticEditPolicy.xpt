/*******************************************************************************
 * Copyright (c) 2011 University of Mannheim: Chair for Software Engineering
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Ralph Gerbig - initial API and implementation and initial documentation
 *******************************************************************************/

/*******************************************************************************

This takes care that classifications are removed from the semantic model even
though they are not visible throug the notational model.

 *******************************************************************************/

«IMPORT 'http://www.eclipse.org/gmf/2009/GenModel'»

«EXTENSION xpt::diagram::editpolicies::Utils»

«AROUND getDestroyElementCommand FOR gmfgen::GenNode-»
«IF self.editPartClassName = 'EntityEditPart' or self.editPartClassName = 'ConnectionEditPart'»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getDestroyElementCommand(org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest req) {
	org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) getHost().getModel();
	org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand cmd = new org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand(getEditingDomain(), null);
	cmd.setTransactionNestingEnabled(false);
	«EXPAND destroyEdges('view')-»
	org.eclipse.emf.ecore.EAnnotation annotation = view.getEAnnotation("Shortcut");«EXPAND xpt::Common::nonNLS»
	if (annotation == null) {
		// there are indirectly referenced children, need extra commands: «childNodes->union(compartments.childNodes->asBag())->exists(not isDirectlyOwned(self))»
«IF hasChildrenOrCompartments(self)-»
		addDestroyChildNodesCommand(cmd);
«ENDIF-»
		addDestroyShortcutsCommand(cmd, view);
		// delete host element
		cmd.add(new org.eclipse.gmf.runtime.emf.type.core.commands.DestroyElementCommand(req));
	} else {«REM»Here, we may play smart and don't generate else for non-toplevel nodes(which can't be shortcuts). Is it worth doing?«ENDREM»
		cmd.add(new org.eclipse.gmf.runtime.diagram.core.commands.DeleteCommand(getEditingDomain(), view));
	}
	
	//*****************************************************************
	//BEGIN Custom Code
	//*****************************************************************
	
	//We need to delete the classification manually when not visible
	de.uni_mannheim.informatik.swt.models.plm.PLM.Classification[] classification = null;
	org.eclipse.ocl.ecore.OCL ocl = org.eclipse.ocl.ecore.OCL.newInstance();
	org.eclipse.ocl.helper.OCLHelper<org.eclipse.emf.ecore.EClassifier, ?, ?, org.eclipse.ocl.ecore.Constraint> helper = ocl.createOCLHelper();
	helper.setContext(de.uni_mannheim.informatik.swt.models.plm.PLM.PLMPackage.Literals.ONTOLOGY);

	try {
		org.eclipse.ocl.expressions.OCLExpression<org.eclipse.emf.ecore.EClassifier> q = helper.createQuery("Classification.allInstances()->select(i| i.type = self or i.instance = self)");
		classification = ((java.util.HashSet<de.uni_mannheim.informatik.swt.models.plm.PLM.Classification>) ocl.evaluate(view.getElement(), q)).toArray(new de.uni_mannheim.informatik.swt.models.plm.PLM.Classification[] {});
	} catch (org.eclipse.ocl.ParserException e) {
		e.printStackTrace();
	}
		
	for(de.uni_mannheim.informatik.swt.models.plm.PLM.Classification i : classification){
		org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest r = new org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest(i, false);
		cmd.add(new org.eclipse.gmf.runtime.emf.type.core.commands.DestroyElementCommand(r));
	}
	
	//*****************************************************************
	//END Custom Code
	//*****************************************************************
	
	return getGEFWrapper(cmd.reduce());
}
«ELSE»
	«targetDef.proceed()»
«ENDIF»
«ENDAROUND»

// @param view - Notation element for the passed node
// assumes 'cmd' to point to composite command
«DEFINE destroyEdges(String view) FOR gmfgen::GenNode-»
«REM»
	XXX: Though semantic editpolicy is supposed to create commands that operate with semantic elements only,
	old code used to delegate child/link deletion to respective editparts, which in turn led to semantic commands
	being combined with notational commands (BaseItemSemanticEditPolicy#addDeleteViewCommand()).
	---
	Use DiagramUpdater.get[Incoming|Outgoing]View instead, to clean links that are not present on a diagram
	(but don't forget to clean corresponding Edge, if any)
«ENDREM-»
«IF genIncomingLinks->notEmpty()-»
	for («EXPAND CodeStyle::G('java.util.Iterator', '?' /*FIXME Refactor once Notation model is Java5*/)» it = «view».getTargetEdges().iterator(); it.hasNext();) {
		org.eclipse.gmf.runtime.notation.Edge incomingLink = (org.eclipse.gmf.runtime.notation.Edge) it.next();
«FOREACH genIncomingLinks AS il-»
		if («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR getDiagram()»(incomingLink) == «EXPAND xpt::editor::VisualIDRegistry::visualID FOR il») {
			«EXPAND impl::diagram::commands::DeleteLinkCommand::newRequest('r', 'incomingLink') FOR il-»
			cmd.add(«EXPAND impl::diagram::commands::DeleteLinkCommand::newInstance('r') FOR il»);
			cmd.add(new org.eclipse.gmf.runtime.diagram.core.commands.DeleteCommand(getEditingDomain(), incomingLink));
			continue;
		}
«ENDFOREACH-»
	}
«ENDIF-»
«IF genOutgoingLinks->notEmpty()-»
	for («EXPAND CodeStyle::G('java.util.Iterator', '?' /*FIXME Refactor once Notation model is Java5*/)» it = «view».getSourceEdges().iterator(); it.hasNext();) {
		org.eclipse.gmf.runtime.notation.Edge outgoingLink = (org.eclipse.gmf.runtime.notation.Edge) it.next();
«FOREACH genOutgoingLinks AS ol-»
		if («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR getDiagram()»(outgoingLink) == «EXPAND xpt::editor::VisualIDRegistry::visualID FOR ol») {
			«EXPAND impl::diagram::commands::DeleteLinkCommand::newRequest('r', 'outgoingLink') FOR ol-»
			cmd.add(«EXPAND impl::diagram::commands::DeleteLinkCommand::newInstance('r') FOR ol»);
			cmd.add(new org.eclipse.gmf.runtime.diagram.core.commands.DeleteCommand(getEditingDomain(), outgoingLink));
			continue;
		}
«ENDFOREACH-»
	}
«ENDIF-»
«ENDDEFINE»